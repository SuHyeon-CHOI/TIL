# 모던 자바스크립트 Deep Dive

## 연산자

### 산술연산자
- 산술 연산자는 피연산자를 대상으로 수학적 계산을 통해 새로운 숫자 값을 만든다. 산술이 불가능한 경우, NaN을 반환한다.
- 이항 산술 연산자
	- 이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.
	- + (덧셈)
	- - (뺄셈)
	- * (곱셈)
	- / (나눗셈)
	- % (나머지)
- 단항 산술 연산자
	- 단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.
	- ++ (증가)
	- -- (감소)
	- 증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.
	- 피연산자 앞에 위치한 증감연산자는 먼저 피연산자의 값을 증감시킨 후, 다른 연산을 수행한다.
	- 피연산자 뒤에 위치한 증감연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증감시킨다.
	```
	var x = 5, result;

	// 선할당 후증가
	result = x++;
	console.log(result, x); // 5 6

	// 선증가 후할당
	result = ++x;
	console.log(result, x); // 7 7

	// 선할당 후감소
	result = x--;
	console.log(result, x); // 7 6

	// 선감소 후할당
	result = --x;
	console.log(result, x); // 5 5
	```
	- - 단항 연산자는 피연산자는 부호를 반전한 값을 반환한다.
- 문자열 연결 연산자
	- + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
	```
	// 문자열 연결 연산자
	'1' + 2; // '12'
	1 + '2'; // '12'

	// 산술 연산자
	1 + 2; // 3

	// true는 1로 타입 변환된다.
	1 + true; // 2

	// false는 0으로 타입 변환된다.
	1 + false; // 1

	// null은 0으로 타입 변환된다.
	1 + null; // 1

	// undefined는 숫자로 타입 변환되지 않는다.
	+undefined; // NaN
	1 + undefined; // NaN
	```
	- 위 예제에서 주목할 것은 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다는 점이다. 이를 암묵적 타입 변환 또는 타입 강제 변환이라고 한다.

### 할당 연산자
- 할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.
- =, +=, -= , 등...
- 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.

### 비교 연산자
- 비교 연산자는 if문이나 for문과 같은 제어문의 조건식에서 주로 사용한다.
- 동등/일치 비교 연산자
	- 동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.
	- 하지만 비교하는 엄격성의 정도가 다르다. 동등 비교 연산자는 느슨한 비교를 하지만, 일치 비교 연산자는 엄격한 비교를 한다.
	- ==, ===, !=, !==
	- 동등 비교(==)연산자는 좌항과 우항의 피연산자를 비교할 떄 먼저 암묵적 타입 변환을 통해 타입을 일치 시킨 후 같은 값인지 비교한다.
	- 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.
	- NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN을 사용한다.
	- 숫자 0도 주의해야 한다. 자바스크립트에는 양의 0과 음의0이 있는데 이들을 비교하면 true를 반환한다.
	-ES6에서 도입된 Object.is 메서드는 예측 가능한 정확한 비교 결과를 반환한다. 그 외에는 일치 비교 연산자)===)와 동일하게 동작한다.
	- 부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 각각 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대 개념이다.
- 대소 관계 비교 연산자
	- <, >, >=, <=

### 삼항 조건 연산자
- 삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.
- 조건식 ? 조건식이 true일 때 반환할 값: 조건식이 false일 때 반환할 값
- 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다.


### 논리 연산자
- 논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다.
- ||, &&, !
- 논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단, 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.
- 논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한 쪽으로 평가된다.

### 쉽표 연산자
- 쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.
```
var x, y, z;
x = 1, y = 2, z = 3; //3
```

### 그룹 연산자
- 소괄호('()')로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 그룹 연산자는 연산자 우선순위가 가장 높다.

### typeof 연산자
- typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.
- typeof 연산자로 null 값을 연산해 보면 'null'이 아닌 'object'를 반환한다는 데에 주의가 필요하다.
- 값이 null 타입인지 확인할 때는 typeof 연산자를 사용하지 말고 일치연산자(===)를 사용하는 것이 좋다.

### 지수 연산자
- ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.
- 지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했다.
- 지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.

## 제어문

### 블록문
- 블록문은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.
- 블록문의 끝에는 세미콜론을 붙이지 않는다.

### 조건문
- 조건문은 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정한다. 조건식은 불리언 값으로 평가될 수 있는 표현식이다.
- if...else문
	- if...else문은 주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다.
	```
	if(조건식) {
		// 조건식이 참이면 이 코드 블록이 실행된다.
	} else {
		// 조건식이 거짓이면 이 코드 블록이 실행된다.
	}
	```
	- if 문의 조건식은 불리언 값으로 평가되어야 한다. 만약 if문의 조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다.
	- 조건식을 추가하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면 else if 문을 사용한다.
- switch문
	- switch문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행 흐름을 옮긴다.
	- switch문의 표현식과 일치하는 case문이 없다면 default문으로 이동한다. default문은 선택사항으로, 사용할 수도 있고 사용하지 않을 수도 있다.
	```
	switch (표현식) {
		case 표현식1:
			switch문의 표현식과 표현식1이 일치하면 실행된 문;
			break;
		case 표현식2:
			switch문의 표현식과 표현식2 가 일치하면 실행될 문;
			break;
		default:
			switch문의 표현식과 일치하는 case문이 없을 때 실행될 문;
	}
	```
	- switch문은 논리적 참, 거짓보다는 다양한 상황에 따라 실행할 코드 블록을 결정할 때 사용한다.
	- default 문에는 break문을 생각하는 것이 일반적이다.

### 반복문
- 반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다.
- for문
	- for문은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다.
	```
	for (변수 선언문 또는 할당문; 조건식; 증감식;) {
		조건식이 참인 경우 반복 실행될 문;
	}
	```
- while문
	- while문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.
	- for문은 반복 횟수가 명확할 때 주로 사용하고, while문은 반복 횟수가 불명확할 때 주로 사용한다.
	```
	var count = 0;

	// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.
	while (count < 3) {
		console.log(count); // 0 1 2
		count++;
	}
	```
	- 조건식의 평가 결과가 언제나 참이면 무한루프가 된다.
- do...while문
	- do...while문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다.
	```
	var count = 0;

	// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.
	do {
		console.log(count); // 0 1 2
		count++;
	} while (count < 3);
	```

### break문
- break문은 레이블 문, 반복문, 또는 switch문의 코드 블록을 탈출한다.

### continue문
- continue문은 반복문의 코드 블록을 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. break문처럼 반복문을 탈출하지는 않는다.

## 타입 변환과 단축 평가

### 타입 변환이란?
- 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다.
- 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 하는데, 이를 암묵적 타입 변환 또는 타입 강제 변환이라 한다.

## 객체 리터럴

### 객체란?
- 자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 '모든 것'이 객체다.
- 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.

### 객체 리터럴에 의한 객체 생성
- 자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.
- 객체 리터럴의 중괄호는 코드 블록을 의미하는 것이 아니다. 코드 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다. 하지만 객체 리터럴은 값으로 평가되는 표현식이기 때문에 객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.


### 프로퍼티
- 객체는 프로퍼티의 집합이며. 프로퍼티는 키와 값으로 구성된다.
- 프로퍼티를 나열할 때는 쉼표(,)로 구분한다.
- 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.

### 메서드
- 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다. 즉, 메서드는 객체에 묶여 있는 함수를 의미한다.

### 프로퍼티 접근
- 프로퍼티에 접근하는 방법은 다음과 같이 두 가지이다.
	- 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법
	- 대괄호 프로퍼티 접근 연산자([...])를 사용하는 대괄호 표기법
- 대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.
- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다.

### 프로퍼티 값 갱신
- 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.

### 프로퍼티 동적 생성
- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.

### 프로퍼티 삭제
- delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로프터 값에 접근할 수 있는 표현식이어야 한다.
